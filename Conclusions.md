#¬ыводы по работе GC.

##Описание.
Приложение создает новые объекты быстрее, чем удалеет.
Сранение проводилось в трех режимах:
1) Heap size = 512M (-Xms:512m, -Xmx:512m)
2) Heap size = 1024M (-Xms:1024m, -Xmx:1024m)
3) Heap size = 2048M (-Xms:2048m, -Xmx:2048m)

По данным логов собирались следующие характеристики по поколением (young, old):
1) Количество сборок.
2) Общее време на сборки.

На основе полученных данных вычислялись минимальные количественные значение 
(време и количество сборок).
Также вычислялось среднее время, потраченное на одну сборку.

##Анализ результатов
На малом размере heap'а каждому из вариантов GC приходилось часто запускать сборки, 
как young так и old.
Наименьшее количество запусков old сборки у G1, при этом он часто делает запуск
сборок young часто.
Наилучшее время на выполнение сборок при G1 засчет быстрого выпонение old сборок.

На среднем размере heap'а ситуация меняется в пользу G1. Old сборки не запускаются, 
при большом количестве young сборок среднее время на выполнение одной сборки 
гораздо ниже прочих GC.
G1 единственный из GC, который не выполнил ни единой old сборки.
Однако при этой G1 показывает наихудшее общее время выполнения сборок.
Наилучший результат при работе Serial. 

На большом размере heap'а наилучшее время выполнения сборок показал Parallel 
засчет отсутствия запусков old сборок и быстрого выполнения young сборок. 
G1 показал наихудшее время выполнения сборок даже при отсутствии old сборок,
несмотря на то, что делает наименьшее количество запусков сборок,
проигрывает в среднем времени на одну сборку почти в 10 раз.
Наиболее эффективным при данных параметрах запуска оказался Parallel
(наименьшее время на выполнение young сборок, отсутствие old сборок 
и наилучшее среднее время на одну young сборку).


##Выводы.
При ограниченном размере heap лучше других себя показывает G1, 
чуть менее хорошо Serial.
При этом CMS оказывается хуже всех по рассмотренным показателям.
С увеличением размера heap'а лучше себя проявляет Serial, 
а при достаточно большом размере heap'а - Parallel.
G1 очень часто проводит сборки, поэтому при большом размере heap'а 
становится менее эффективным.


