#¬ыводы по работе GC.

##Описание.
Приложение создает новые объекты быстрее, чем удалеет.
Сранение проводилось в трех режимах:
1) Heap size = 512M (-Xms:512m, -Xmx:512m)
2) Heap size = 1024M (-Xms:1024m, -Xmx:1024m)
3) Heap size = 2048M (-Xms:2048m, -Xmx:2048m)

По данным логов собирались следующие характеристики по поколением (young, old):
1) Количество сборок.
2) Общее време на сборки.
3) Величина максимальной паузы на young сборке.

На основе полученных данных вычислялись минимальные количественные значение 
(време и количество сборок).
Также вычислялось среднее время, потраченное на одну сборку.
Вычислялась пропускная способность - отношение времени, потраченного на сборку, 
к общему времени выполнения приложения.


##Анализ результатов
На малом размере heap'а каждому из вариантов GC приходилось часто запускать сборки, 
как young так и old.
Наименьшее количество запусков old сборки у G1, при этом он часто делает запуск
сборок young часто.
Наилучшее время на выполнение сборок при G1 засчет быстрого выпонение old сборок.
G1 показал лучший результат по максимальной паузе на young сборке, а также по пропускной 
способности.

На среднем размере heap'а ситуация меняется в пользу G1. Old сборки не запускаются, 
при большом количестве young сборок среднее время на выполнение одной сборки 
гораздо ниже прочих GC.
G1 единственный из GC, который не выполнил ни единой old сборки.
Однако при этой G1 показывает наихудшее общее время выполнения сборок.
Наилучший результат при работе Serial. 
Лучшее время максимальной паузы у Parallel, однако, лучшая пропускная способность
у G1.

На большом размере heap'а наилучшее время выполнения сборок показал Parallel 
засчет отсутствия запусков old сборок и быстрого выполнения young сборок. 
G1 показал наихудшее время выполнения сборок даже при отсутствии old сборок,
несмотря на то, что делает наименьшее количество запусков сборок,
проигрывает в среднем времени на одну сборку почти в 10 раз.
Наиболее эффективным при данных параметрах запуска оказался Parallel
(наименьшее время на выполнение young сборок, отсутствие old сборок 
и наилучшее среднее время на одну young сборку).
Лучшая максимальная пауза опять у Parallel, но стоит отметить также, что CMS отстал 
незначительно.
Лучшая пропускная способность у Parallel также. 


##Выводы.
При ограниченном размере heap лучше других себя показывает G1, 
чуть менее хорошо Serial.
При этом CMS оказывается хуже всех по рассмотренным показателям.
С увеличением размера heap'а лучше себя проявляет Serial, 
а при достаточно большом размере heap'а - Parallel.
G1 достаточно хорошо показал себя в разных условиях.
Главный вывод, который можно сделать - выбор зависит от настроек VM.
При ограниченных ресурсах стоит использовать G1.
Но при расширении ресурсов (размера heap'а прежде всего) эффективнее всего 
справляется с задачей Parallel.


